#!/usr/bin/env python


from functools import total_ordering
from list_py_oo_tests import testList


# We want to encode the following algebraic data type:
#
#    data List a = Nil | Cons { head :: a, tail :: List a }
#
# We've seen a Scott encoding, which uses a "match" function as the interface.
# Everything else is built in terms of that one function.
#
# We've also seen that everything can be written in terms of a "fold" function
# (List's "fold" function is called "foldRight").  Folding is a lot like the
# "match", but does some recursion for us.
#
# This leads to the Church encoding of data types, which uses "fold" function
# on the interface of the data type, instead of "match".

@total_ordering
class List:

    # List :
    #     (               # foldRight
    #         b           #    ifNil
    #         -> (        #    ifCons
    #             ( a     #        head
    #             , b     #        folded tail
    #             ) -> b  #        returned (ifCons)
    #         ) -> b      #    returned (foldRight)
    #     ) -> List a     # returned
    def __init__(self, foldRight):
        self.foldRight = foldRight

    # Here's some constructors to get you started.

    # nil : List a
    @staticmethod
    def nil():
        return List(lambda ifNil, ifCons: ifNil)

    # cons :
    #     (  a          # head
    #     ,  List a     # tail
    #     ) -> List a   # returned
    @staticmethod
    def cons(head, tail):
        return List(
            lambda ifNil, ifCons: ifCons(head, tail.foldRight(ifNil, ifCons)))

    # new :
    #     *a         # elems
    #     -> List a  # returned
    @staticmethod
    def new(*elems):
        res = List.nil()
        for e in reversed(elems):
            res = List.cons(e, res)
        return res

    # If we can just implement `match` in terms of `foldRight`, then everything
    # falls in place.  We can use all the implementations from before, just as
    # they are.

    # match :
    #     List a        # self
    #     ->  b         #    ifNil
    #     -> (          #    ifCons
    #         ( a       #        head
    #         , List a  #        tail
    #         ) -> b    #        returned (ifCons)
    #     ) -> b        #    returned
    def match(self, ifNil, ifCons):
        raise BaseException("TODO")

    # Now you have both a `match` and a `foldRight`, so the rest should fall in
    # place.

    # is_nil :
    #     List a      # self
    #     -> Boolean  # returned
    def is_nil(self):
        raise BaseException("TODO")

    # is_cons :
    #     List a      # self
    #     -> Boolean  # returned
    def is_cons(self):
        raise BaseException("TODO")

    # push :
    #     ( List a     # self
    #     , a          # elem
    #     ) -> List a  # returned
    def push(self, elem):
        raise BaseException("TODO")

    # __eq__ :
    #     ( List a      # self
    #     , List a      # other
    #     ) -> Boolean  # returned
    def __eq__(self, other):
        raise BaseException("TODO")

    # __le__ :
    #     ( List a      # self
    #     , List a      # other
    #     ) -> Boolean  # returned
    def __le__(self, other):
        raise BaseException("TODO")

    # __repr__ :
    #     List a     # self
    #     -> String  # returned
    def __repr__(self):
        raise BaseException("TODO")

    # toPyList :
    #     List a  # self
    #     -> [a]  # returned
    def toPyList(self):
        raise BaseException("TODO")

    # append :
    #     ( List a     # self
    #     , List a     # l
    #     ) -> List a  # returned
    def append(self, l):
        raise BaseException("TODO")

    # length :
    #     List a  # self
    #     -> Int  # returned
    def length(self):
        raise BaseException("TODO")

    # all :
    #     ( List a        # self
    #     , a -> Boolean  # cond
    #     ) -> Boolean    # returned
    def all(self, cond):
        raise BaseException("TODO")

    # any :
    #     ( List a        # self
    #     , a -> Boolean  # cond
    #     ) -> Boolean    # returned
    def any(self, cond):
        raise BaseException("TODO")

    # map :
    #     ( List a     # self
    #     , a -> b     # f
    #     ) -> List b  # returned
    def map(self, f):
        raise BaseException("TODO")

    # flatMap :
    #     ( List a       # self
    #     , a -> List b  # f
    #     ) -> List b    # returned
    def flatMap(self, f):
        raise BaseException("TODO")

    # flatten :
    #     List (List a)  # self
    #     -> List a      # returned
    def flatten(self):
        raise BaseException("TODO")

    # keep :
    #     ( List a        # self
    #     , a -> Boolean  # should_keep (if true)
    #     ) -> List a     # returned
    def keep(self, should_keep):
        raise BaseException("TODO")

    # discard :
    #     ( List a        # self
    #     , a -> Boolean  # should_discard (if true)
    #     ) -> List a     # returned
    def discard(self, should_discard):
        raise BaseException("TODO")

    # headList :
    #     List a     # self
    #     -> List a  # returned (either empty or just a head)
    def headList(self):
        raise BaseException("TODO")

    # headOrElse :
    #     List a  # self
    #     a       # default
    #     -> a    # returned (head or default)
    def headOrElse(self, default):
        raise BaseException("TODO")

    # tailList :
    #     List a            # self
    #     -> List (List a)  # returned
    def tailList(self):
        raise BaseException("TODO")

    # foldLeft :
    #     ( List a       # self
    #     , b            # z
    #     , (b, a) -> b  # f
    #     ) -> b         # returned
    def foldLeft(self, z, f):
        raise BaseException("TODO")

    # reverse :
    #     List a     # self
    #     -> List a  # returned
    def reverse(self):
        raise BaseException("TODO")

    # discardFirst :
    #     ( List a        # self
    #     , a -> Boolean  # should_discard (if true)
    #     ) -> List a     # returned
    def discardFirst(self, should_discard):
        raise BaseException("TODO")

    # takeWhile :
    #     ( List a        # self
    #     , a -> Boolean  # should_take (if true)
    #     ) -> List a     # returned
    def takeWhile(self, should_take):
        raise BaseException("TODO")

    # dropWhile :
    #     ( List a        # self
    #     , a -> Boolean  # should_drop (if true)
    #     ) -> List a     # returned
    def dropWhile(self, should_drop):
        raise BaseException("TODO")

    # drop :
    #     ( List a     # self
    #     , Integer    # n
    #     ) -> List a  # returned
    #
    def drop(self, n):
        raise BaseException("TODO")

    # take :
    #     ( List a     # self
    #     , Integer    # n
    #     ) -> List a  # returned
    #
    def take(self, n):
        raise BaseException("TODO")

    # zipWith :
    #     ( List a       # self
    #     , List b       # other
    #     , (a, b) -> c  # f
    #     ) -> List c    # returned
    #
    def zipWith(self, other, f):
        raise BaseException("TODO")


testList(List)
