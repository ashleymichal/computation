#!/usr/bin/env python


from functools import total_ordering
from list_py_oo_tests import testList


# We want to encode the following algebraic data type:
#
#    data List a = Nil | Cons { head :: a, tail :: List a }
#
# but in a language that doesn't have a good syntax for sum types (in this
# case, Python). Most languages popular in industry only have good support for
# product types (grouping things together like with tuples or classes), but not
# very good options for choosing from different possibilities. We get some
# built-in sum types, like a boolean type (which can either be true or false),
# but we don't get good support for custom sum types.
#
# But sum types arise in programming all the times.  For instance, think about
# JSON.  We might say something like
#
#    data Json
#        = JString String
#        | JNumber Double
#        | JBool Bool
#        | JObject (Map String Json)
#        | JArray [Json]
#        | JNull
#
# With the exception of using better underlying representations than String and
# Double, this data type algebraically exactly matches the JSON specification.
#
# But for now, let's start with our List, which only has two options. How might
# we encode this list in Python? We'll start with an interface that can tell us
# if we have a Nil or a Cons. Then, if we have a Cons, then we'll have some
# methods to help us unpack it into a head and a tail. Here's what that looks
# like:

@total_ordering
class List:

    # Here's the interface of our abstraction -- a base set of values
    # (`is_nil`, `head`, and `tail`) from which everything else can be derived.
    # `head` and `tail` as unfortunately partial functions (the throw
    # exceptions if called on an empty list), but we'll accept this for now.
    # There's some benefits for performance and stack-safety with this
    # approach.

    def __init__(self, is_nil, head, tail):
        self.__is_nil = is_nil
        self.__head = head
        self.__tail = tail

    def is_nil(self):
        return self.__is_nil

    def is_cons(self):
        return not self.__is_nil

    def head(self):
        return self.__head()

    def tail(self):
        return self.__tail()

    # Now we'll make two constructors for this interface, one for nil (the
    # empty list), and the other for cons.

    # nil : List a
    @staticmethod
    def nil():
        def fail(msg): raise BaseException(msg)
        return List(
            True,
            lambda: fail("empty list has no head"),
            lambda: fail("empty list has no tail"))

    # cons :
    #     (  a          # head
    #     ,  List a     # tail
    #     ) -> List a   # returned
    @staticmethod
    def cons(head, tail):
        return List(False, lambda: head, lambda: tail)

    # Here's a `new` function to construct lists with less syntax than using
    # `cons` and `nil` directly.

    # new :
    #     *a         # elems
    #     -> List a  # returned
    @staticmethod
    def new(*elems):
        res = List.nil()
        for e in reversed(elems):
            res = List.cons(e, res)
        return res

    # For convenience, here's a method-based `cons`, which we'll call `push`.

    # push :
    #     ( List a     # self
    #     , a          # elem
    #     ) -> List a  # returned
    def push(self, elem):
        return List.cons(elem, self)

    # And here's `__eq__` and `__le__` implemented for assertion testing, and
    # to illustrate how our interface helps us get "pattern matching," which is
    # an important feature of sum types. If we have multiple possible data
    # constructors, we need a way to test which one we have and safely extract
    # things out of it.

    # __eq__ :
    #     ( List a      # self
    #     , List a      # other
    #     ) -> Boolean  # returned
    def __eq__(self, other):
        if self.is_nil():
            if other.is_nil():
                return True
            elif other.is_cons():
                return False
            #
            # Note, a sum type is has a finite number of possibilities. In some
            # languages that support sum types well, a checker can validate
            # that all the cases have been addressed.
            #
            # This else block is needless because we've defined `is_cons` as
            # the negation of `is_nil`.
            else:
                raise BaseException("should never reach here")
        else:
            if other.is_nil():
                return False
            else:
                # Calling `head` and `tail` in this block is safe, because we
                # know `is_cons` is true in this block. We're encoding pattern
                # matching by convention in this way.
                return (((self.head() == other.head()) and
                         (self.tail() == other.tail())))

    # __le__ :
    #     ( List a      # self
    #     , List a      # other
    #     ) -> Boolean  # returned
    def __le__(self, other):
        if self.is_nil():
            return True
        else:
            if other.is_nil():
                return False
            else:
                return (((self.head() <= other.head()) and
                         (self.tail() <= other.tail())))

    # Notice how careful we have to be to make sure to call `is_nil` to check
    # which case we have, otherwise we can have some exceptions thrown when we
    # call head or tail. The following `match` method will do this check and
    # calls for us. That way, we'll never call `head` or `tail` directly. This
    # makes `match` a total function (one that has a valid return value for
    # every
    # possible value of the input's type).

    # match :
    #     List a        # self
    #     ->  b         #    ifNil
    #     -> (          #    ifCons
    #         ( a       #        head
    #         , List a  #        tail
    #         ) -> b    #        returned (ifCons)
    #     ) -> b        #    returned
    def match(self, ifNil, ifCons):
        raise BaseException("TODO")

    # Now we're going to implement a very important function for any algebraic
    # data type -- the catamorphism -- more colloquially called a "fold"
    # function. The one for list is often called "foldRight".
    #
    # The `__repr__` function below is written in terms of `foldRight`. See if
    # you can implement `foldRight` such that that assertion for `__repr__`
    # passes.

    # foldRight :
    #     ( List a       # self
    #     , b            # ifEmpty
    #     , (a, b) -> b  # ifCons
    #     ) -> b         # returned
    def foldRight(self, ifEmpty, ifCons):
        raise BaseException("TODO")

    # It turns out you can write `match` in terms of `foldRight` or `foldRight`
    # in terms of `match`. Try to do both.

    # __repr__ :
    #     List a     # self
    #     -> String  # returned
    def __repr__(self):
        return ("[" +
                self.foldRight(
                    ("]", True),
                    lambda a, acc:
                        (repr(a) + ("" if acc[1] else ", ") + acc[0],
                         False))[0])

    # The remaining unimplemented functions can all be written in terms of
    # `foldRight`, `match`, or each other. They have been loosely ordered with
    # more simple ones earlier that can be used to implement later ones.
    #
    # You should not call `is_nil`, `head`, or `tail` at all. We've hidden
    # these partial functions behind the total function `match`.
    #
    # Now let's try to write as much as we can in terms of `foldRight` instead
    # of `match`. We should find that `foldRight` is just as expressive, but
    # sometimes not efficient or stack-safe. For now, don't worry about
    # performance or stack-safety. Just practice using `foldRight`.
    #
    # Remember, the trick with `foldRight` is that it replaces data
    # constructors with operations.

    # toPyList :
    #     List a  # self
    #     -> [a]  # returned
    def toPyList(self):
        raise BaseException("TODO")

    # append :
    #     ( List a     # self
    #     , List a     # l
    #     ) -> List a  # returned
    def append(self, l):
        raise BaseException("TODO")

    # length :
    #     List a  # self
    #     -> Int  # returned
    def length(self):
        raise BaseException("TODO")

    # all :
    #     ( List a        # self
    #     , a -> Boolean  # cond
    #     ) -> Boolean    # returned
    def all(self, cond):
        raise BaseException("TODO")

    # any :
    #     ( List a        # self
    #     , a -> Boolean  # cond
    #     ) -> Boolean    # returned
    def any(self, cond):
        raise BaseException("TODO")

    # map :
    #     ( List a     # self
    #     , a -> b     # f
    #     ) -> List b  # returned
    def map(self, f):
        raise BaseException("TODO")

    # flatMap :
    #     ( List a       # self
    #     , a -> List b  # f
    #     ) -> List b    # returned
    def flatMap(self, f):
        raise BaseException("TODO")

    # flatten :
    #     List (List a)  # self
    #     -> List a      # returned
    def flatten(self):
        raise BaseException("TODO")

    # keep :
    #     ( List a        # self
    #     , a -> Boolean  # should_keep (if true)
    #     ) -> List a     # returned
    def keep(self, should_keep):
        raise BaseException("TODO")

    # discard :
    #     ( List a        # self
    #     , a -> Boolean  # should_discard (if true)
    #     ) -> List a     # returned
    def discard(self, should_discard):
        raise BaseException("TODO")

    # headList :
    #     List a     # self
    #     -> List a  # returned (either empty or just a head)
    def headList(self):
        raise BaseException("TODO")

    # headOrElse :
    #     List a  # self
    #     a       # default
    #     -> a    # returned (head or default)
    def headOrElse(self, default):
        raise BaseException("TODO")

    # tailList :
    #     List a            # self
    #     -> List (List a)  # returned
    def tailList(self):
        raise BaseException("TODO")

    # Write `reverse` in terms of `foldLeft` to test both.

    # foldLeft :
    #     ( List a       # self
    #     , b            # z
    #     , (b, a) -> b  # f
    #     ) -> b         # returned
    def foldLeft(self, z, f):
        raise BaseException("TODO")

    # reverse :
    #     List a     # self
    #     -> List a  # returned
    def reverse(self):
        raise BaseException("TODO")

    # discardFirst :
    #     ( List a        # self
    #     , a -> Boolean  # should_discard (if true)
    #     ) -> List a     # returned
    def discardFirst(self, should_discard):
        raise BaseException("TODO")

    # takeWhile :
    #     ( List a        # self
    #     , a -> Boolean  # should_take (if true)
    #     ) -> List a     # returned
    def takeWhile(self, should_take):
        raise BaseException("TODO")

    # dropWhile :
    #     ( List a        # self
    #     , a -> Boolean  # should_drop (if true)
    #     ) -> List a     # returned
    def dropWhile(self, should_drop):
        raise BaseException("TODO")

    # drop :
    #     ( List a     # self
    #     , Integer    # n
    #     ) -> List a  # returned
    #
    def drop(self, n):
        raise BaseException("TODO")

    # take :
    #     ( List a     # self
    #     , Integer    # n
    #     ) -> List a  # returned
    #
    def take(self, n):
        raise BaseException("TODO")

    # zipWith :
    #     ( List a       # self
    #     , List b       # other
    #     , (a, b) -> c  # f
    #     ) -> List c    # returned
    #
    def zipWith(self, other, f):
        raise BaseException("TODO")


testList(List)
