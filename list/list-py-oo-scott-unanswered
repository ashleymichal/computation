#!/usr/bin/env python


from functools import total_ordering
from list_py_oo_tests import testList


# We want to encode the following algebraic data type:
#
#    data List a = Nil | Cons { head :: a, tail :: List a }
#
# We saw a naive way of encoding pattern matching into Python. But this
# involved using partial functions like head and tail. What if these functions
# weren't even provided?
#
# We're going to encode pattern matching more directly using first class
# functions (Python lambdas). And with this encoding we should have an
# implementation that uses no partial functions at all.  This encoding is
# sometimes called a Scott encoding, named after Dana Scott.

@total_ordering
class List:

    # List :
    #     (                 # match
    #         b             #    ifNil
    #         -> (          #    ifCons
    #             ( a       #        head
    #             , List a  #        tail
    #             ) -> b    #        returned (ifCons)
    #         ) -> b        #    returned (match)
    #     ) -> List a       # returned
    def __init__(self, match):
        self.match = match

    # The type signature of the match lambda is a more complex than what's
    # normally passed to constructors in Python. It captures the essence of
    # pattern matching but without recursion (unlike foldRight).
    #
    # The `match` function takes two arguments: one for the "nil" case, and the
    # other for "cons." In "cons" case, we know we'll have a head and tail so
    # we pass in a function that consumed these two.

    # Here's a simple example of using match to define `is_nil` and `is_cons`.
    # Note that everything will be definable in terms of `match`. So to define
    # a list, we'll see that the only function we need on our List interface is
    # just this one.

    # is_nil :
    #     List a      # self
    #     -> Boolean  # returned
    def is_nil(self):
        return self.match(True, lambda h, t: False)

    # is_cons :
    #     List a      # self
    #     -> Boolean  # returned
    def is_cons(self):
        return self.match(False, lambda h, t: True)

    # But you'll never have to use `is_nil` or `is_cons`. The `match` function
    # is superior because it doesn't suffer from what's called "boolean
    # blindness."

    # Now see if you can implement everything in this file. But if you already,
    # did work for the previous encoding, you'll find a lot of answers there
    # port directly over once if you wrote them in terms of `foldRight` or
    # `foldLeft`.

    # nil : List a
    @staticmethod
    def nil():
        raise BaseException("TODO")

    # cons :
    #     (  a          # head
    #     ,  List a     # tail
    #     ) -> List a   # returned
    @staticmethod
    def cons(head, tail):
        raise BaseException("TODO")

    # new :
    #     *a         # elems
    #     -> List a  # returned
    @staticmethod
    def new(*elems):
        raise BaseException("TODO")

    # push :
    #     ( List a     # self
    #     , a          # elem
    #     ) -> List a  # returned
    def push(self, elem):
        raise BaseException("TODO")

    # __eq__ :
    #     ( List a      # self
    #     , List a      # other
    #     ) -> Boolean  # returned
    def __eq__(self, other):
        raise BaseException("TODO")

    # __le__ :
    #     ( List a      # self
    #     , List a      # other
    #     ) -> Boolean  # returned
    def __le__(self, other):
        raise BaseException("TODO")

    # foldRight :
    #     ( List a       # self
    #     , b            # ifEmpty
    #     , (a, b) -> b  # ifCons
    #     ) -> b         # returned
    def foldRight(self, ifEmpty, ifCons):
        raise BaseException("TODO")

    # __repr__ :
    #     List a     # self
    #     -> String  # returned
    def __repr__(self):
        raise BaseException("TODO")

    # toPyList :
    #     List a  # self
    #     -> [a]  # returned
    def toPyList(self):
        raise BaseException("TODO")

    # append :
    #     ( List a     # self
    #     , List a     # l
    #     ) -> List a  # returned
    def append(self, l):
        raise BaseException("TODO")

    # length :
    #     List a  # self
    #     -> Int  # returned
    def length(self):
        raise BaseException("TODO")

    # all :
    #     ( List a        # self
    #     , a -> Boolean  # cond
    #     ) -> Boolean    # returned
    def all(self, cond):
        raise BaseException("TODO")

    # any :
    #     ( List a        # self
    #     , a -> Boolean  # cond
    #     ) -> Boolean    # returned
    def any(self, cond):
        raise BaseException("TODO")

    # map :
    #     ( List a     # self
    #     , a -> b     # f
    #     ) -> List b  # returned
    def map(self, f):
        raise BaseException("TODO")

    # flatMap :
    #     ( List a       # self
    #     , a -> List b  # f
    #     ) -> List b    # returned
    def flatMap(self, f):
        raise BaseException("TODO")

    # flatten :
    #     List (List a)  # self
    #     -> List a      # returned
    def flatten(self):
        raise BaseException("TODO")

    # keep :
    #     ( List a        # self
    #     , a -> Boolean  # should_keep (if true)
    #     ) -> List a     # returned
    def keep(self, should_keep):
        raise BaseException("TODO")

    # discard :
    #     ( List a        # self
    #     , a -> Boolean  # should_discard (if true)
    #     ) -> List a     # returned
    def discard(self, should_discard):
        raise BaseException("TODO")

    # headList :
    #     List a     # self
    #     -> List a  # returned (either empty or just a head)
    def headList(self):
        raise BaseException("TODO")

    # headOrElse :
    #     List a  # self
    #     a       # default
    #     -> a    # returned (head or default)
    def headOrElse(self, default):
        raise BaseException("TODO")

    # tailList :
    #     List a            # self
    #     -> List (List a)  # returned
    def tailList(self):
        raise BaseException("TODO")

    # foldLeft :
    #     ( List a       # self
    #     , b            # z
    #     , (b, a) -> b  # f
    #     ) -> b         # returned
    def foldLeft(self, z, f):
        raise BaseException("TODO")

    # reverse :
    #     List a     # self
    #     -> List a  # returned
    def reverse(self):
        raise BaseException("TODO")

    # discardFirst :
    #     ( List a        # self
    #     , a -> Boolean  # should_discard (if true)
    #     ) -> List a     # returned
    def discardFirst(self, should_discard):
        raise BaseException("TODO")

    # takeWhile :
    #     ( List a        # self
    #     , a -> Boolean  # should_take (if true)
    #     ) -> List a     # returned
    def takeWhile(self, should_take):
        raise BaseException("TODO")

    # dropWhile :
    #     ( List a        # self
    #     , a -> Boolean  # should_drop (if true)
    #     ) -> List a     # returned
    def dropWhile(self, should_drop):
        raise BaseException("TODO")

    # drop :
    #     ( List a     # self
    #     , Integer    # n
    #     ) -> List a  # returned
    #
    def drop(self, n):
        raise BaseException("TODO")

    # take :
    #     ( List a     # self
    #     , Integer    # n
    #     ) -> List a  # returned
    #
    def take(self, n):
        raise BaseException("TODO")

    # zipWith :
    #     ( List a       # self
    #     , List b       # other
    #     , (a, b) -> c  # f
    #     ) -> List c    # returned
    #
    def zipWith(self, other, f):
        raise BaseException("TODO")


testList(List)
